# Nginx Configuration for Kubernetes Webstack Frontend
# =====================================================
# This configuration serves static files AND proxies API requests to the backend.
#
# WHY A CUSTOM NGINX CONFIG?
# - Default nginx.conf only serves static files
# - We need to proxy /api/* requests to the backend container
# - This avoids CORS issues (same-origin policy)
# - This is used in both Docker Compose and Kubernetes (via ConfigMap)
#
# KEY CONCEPTS:
# - server: Defines a virtual server that handles requests
# - location: Matches URL paths and defines how to handle them
# - proxy_pass: Forwards requests to another server

# ==============================================================================
# HTTP SERVER
# ==============================================================================
server {
    # Listen on port 80 (standard HTTP port)
    # WHY 80?
    # - Standard HTTP port
    # - Container-internal, so no privilege issues
    listen 80;
    
    # Server name (hostname)
    # WHY _ (underscore)?
    # - Catch-all server name
    # - Matches any hostname
    server_name _;

    # ==========================================================================
    # STATIC FILE SERVING (Root location)
    # ==========================================================================
    location / {
        # Document root - where static files are located
        # WHY /usr/share/nginx/html?
        # - Default Nginx document root
        # - Our Dockerfile copies index.html here
        root /usr/share/nginx/html;
        
        # Default file to serve
        # WHY index.html?
        # - Standard web convention
        # - Browsers request / and get index.html
        index index.html;
        
        # Try to serve the requested file, fall back to index.html
        # WHY try_files?
        # - First tries to serve the exact file requested
        # - Falls back to index.html for SPA-style routing
        try_files $uri $uri/ /index.html;
    }

    # ==========================================================================
    # API PROXY (Backend requests)
    # ==========================================================================
    # Forward all /api/* requests to the backend service
    location /api/ {
        # Proxy to backend service
        # WHY use service name?
        # - Docker Compose: svb-backend is the service name (DNS-resolved)
        # - Kubernetes: Uses environment variable or ConfigMap
        # 
        # NOTE: This value is replaced by envsubst or ConfigMap in K8s
        # For Docker Compose, we use the hardcoded service name
        proxy_pass http://svb-backend:8000;
        
        # Proxy headers - forward client information to backend
        # WHY these headers?
        # - Host: Original host requested by client
        # - X-Real-IP: Client's actual IP address
        # - X-Forwarded-For: Chain of proxy IPs
        # - X-Forwarded-Proto: Original protocol (http/https)
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeout settings
        # WHY configure timeouts?
        # - Prevents hanging connections
        # - 60s is reasonable for most API calls
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # ==========================================================================
    # HEALTH CHECK ENDPOINT
    # ==========================================================================
    # Simple health check for the frontend itself
    location /health {
        # Return 200 OK with a simple message
        # WHY?
        # - Kubernetes needs to check if Nginx is running
        # - This is separate from backend health
        return 200 'Frontend OK\n';
        add_header Content-Type text/plain;
    }
}
