services:
  # container voor postgreSQL database
  svb-database:
    # kleine image voor postgreSQL
    image: postgres:15-alpine
    
    container_name: svb-database
    
    # aangezien we docker niet gebruiken als "productie" en puur om te testen is het makkelijker om de env vars te hardcoden
    # dit is natuurlijk geen goede praktijk maar voor een testomgeving is het makkelijker
    environment:
      POSTGRES_DB: webstack        
      POSTGRES_USER: postgres    
      POSTGRES_PASSWORD: postgres # "password = password" ahhh
    
   
    volumes:
      - svb-db-data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    
    # healthchecks om te testen of alles goed draait, het zelfde princiepe (hoe deze container getest wordt) wordt ook gebruikt in k8s
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d webstack"]
      interval: 5s      
      timeout: 5s       
      retries: 5        
      start_period: 10s 
    
    networks:
      - svb-network

  # FastAPI backend  
  svb-backend:
    # gebruikt dockerfile
    build:
      context: ./backend
      dockerfile: Dockerfile
    
    image: svb-backend:latest
    
    container_name: svb-backend
    
   # opnieuw, dit is een test omgeving, hipitihopeti
    environment:
      DB_HOST: svb-database   
      DB_PORT: "5432"         
      DB_NAME: webstack      
      DB_USER: postgres       
      DB_PASSWORD: postgres    
    
    # expose poort 8000 aan de "buitenwereld"
    ports:
      - "8000:8000"
    
    # aangezien de backend afhankelijk is van de database moet deze wachten tot de database is opgestart
    depends_on:
      svb-database:
        condition: service_healthy
    
    restart: unless-stopped
    
    networks:
      - svb-network

 # frontend via Nginx webserver
  svb-frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    
    image: svb-frontend:latest
    
    container_name: svb-frontend
    
   # we gebruiken poort 8080 omdat dit een testomgevnig is, zo clutteren we niet de poorten van de host 
    ports:
      - "8080:80"
    
    # aangezien de frontend afhankelijk is van de backend moet deze wachten tot de backend is opgestart
    depends_on:
      - svb-backend
    
    restart: unless-stopped
    
    networks:
      - svb-network

# we gebruiken een intern netwerk om de containers met elkaar te laten praaten
networks:
  svb-network:
    driver: bridge



volumes:
  svb-db-data:
    driver: local
